name: 🚀 Automated Release Generator

on:
  workflow_dispatch:
    inputs:
      release-type:
        description: 'Type of release to create'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
          - prerelease
      enable-ai-enhancement:
        description: 'Use AI to enhance release descriptions'
        required: false
        default: false
        type: boolean
      publish-npm:
        description: 'Publish to npm registry'
        required: false
        default: false
        type: boolean
  push:
    tags:
      - 'v*'
  pull_request:
    types: [closed]
    branches:
      - main
  schedule:
    # Weekly release notes generation (Sundays at midnight UTC)
    - cron: '0 0 * * 0'

# Centralized timeout and security settings
# These timeouts prevent runaway processes and ensure resource efficiency
env:
  AI_EXECUTION_TIMEOUT_MINUTES: ${{ vars.AI_EXECUTION_TIMEOUT_MINUTES || '10' }}
  WORKFLOW_TIMEOUT: 30          # Maximum runtime for entire workflow (safety limit)
  AI_OPERATION_TIMEOUT: 15      # Timeout for AI enhancement operations (cost control)
  API_OPERATION_TIMEOUT: 10     # Timeout for GitHub API calls (reliability)
  SETUP_TIMEOUT: 5              # Timeout for environment setup (fast-fail on setup issues)

# Minimal required permissions
permissions:
  contents: read
  issues: write
  pull-requests: read
  actions: read

# Prevent concurrent runs for the same workflow
concurrency:
  group: release-notes-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Emergency controls check - validates system state before proceeding
  # Integrates with repository-wide emergency controls for coordinated workflow management
  emergency-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      can-proceed: ${{ steps.check.outputs.can-proceed }}
      emergency-reason: ${{ steps.check.outputs.emergency-reason }}
    steps:
      - name: Check Emergency Controls
        id: check
        run: |
          echo "🔍 Checking emergency controls..."

          # EMERGENCY_STOP: Repository variable that immediately halts all AI workflows
          # Used for critical incidents, budget overruns, or system-wide issues
          if [[ "${{ vars.EMERGENCY_STOP }}" == "true" ]]; then
            echo "🚨 Release notes generation blocked by emergency stop"
            echo "can-proceed=false" >> $GITHUB_OUTPUT
            echo "emergency-reason=Emergency stop activated" >> $GITHUB_OUTPUT
          # MAINTENANCE_MODE: Repository variable that pauses workflows during system updates
          # Prevents workflow conflicts during infrastructure changes
          elif [[ "${{ vars.MAINTENANCE_MODE }}" == "true" ]]; then
            echo "🔧 Release notes generation paused for maintenance"
            echo "can-proceed=false" >> $GITHUB_OUTPUT
            echo "emergency-reason=Maintenance mode active" >> $GITHUB_OUTPUT
          else
            echo "✅ Release notes generation can proceed"
            echo "can-proceed=true" >> $GITHUB_OUTPUT
            echo "emergency-reason=" >> $GITHUB_OUTPUT
          fi

  # Analyze commits and calculate version
  analyze-commits:
    needs: emergency-check
    if: |
      needs.emergency-check.outputs.can-proceed == 'true' &&
      (github.event_name != 'pull_request' || github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      analysis-available: ${{ steps.analyze.outputs.analysis-available }}
      current-version: ${{ steps.analyze.outputs.current-version }}
      next-version: ${{ steps.analyze.outputs.next-version }}
      bump-type: ${{ steps.analyze.outputs.bump-type }}
      has-changes: ${{ steps.analyze.outputs.has-changes }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for commit analysis
          fetch-tags: true  # Ensure tags are fetched for version detection

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        timeout-minutes: ${{ fromJSON(env.SETUP_TIMEOUT) }}
        run: |
          python -m pip install --upgrade pip
          pip install -e dev-scripts/version-management/

          # Verify installation
          python -c "import yaml, json, subprocess, sys; print('Dependencies OK')"

          # Test analyze-commits.py can be imported
          python -c "import sys; sys.path.insert(0, 'dev-scripts/version-management'); " \
            "exec(open('dev-scripts/version-management/analyze-commits.py').read())" --help || true

      - name: Cache git analysis results
        uses: actions/cache@v4
        with:
          path: .git-analysis-cache
          key: git-analysis-${{ runner.os }}-${{ github.sha }}-${{ hashFiles('.github/semver-config.yml') }}
          restore-keys: |
            git-analysis-${{ runner.os }}-${{ github.sha }}-
            git-analysis-${{ runner.os }}-

      - name: Analyze commits
        id: analyze
        run: |
          echo "📊 Analyzing commits for version calculation..."

          # Determine base reference (always use latest tag)
          BASE_REF=""
          if [[ -z "$BASE_REF" ]]; then
            # Get latest tag or use beginning of history
            if git describe --tags --abbrev=0 >/dev/null 2>&1; then
              BASE_REF=$(git describe --tags --abbrev=0)
              echo "Using latest tag as base: $BASE_REF"
            else
              echo "No tags found, analyzing all commits"
              BASE_REF=""
            fi
          fi

          # Run commit analysis
          ANALYSIS_FILE="commit-analysis.json"
          ERROR_FILE="analysis-error.log"

          if [[ -n "$BASE_REF" ]]; then
            echo "Running analyze-commits.py with base ref: $BASE_REF"
            if ! timeout 120 python dev-scripts/version-management/analyze-commits.py \
              --since "$BASE_REF" \
              --output json \
              --verbose > "$ANALYSIS_FILE" 2>"$ERROR_FILE"; then
              echo "❌ Error running analyze-commits.py with base ref $BASE_REF (exit code: $?):"
              cat "$ERROR_FILE"
              echo "--- Analysis file content (if any) ---"
              cat "$ANALYSIS_FILE" || echo "No analysis file created"
              exit 1
            fi
          else
            echo "Running analyze-commits.py for all commits (with 2-minute timeout)"
            if ! timeout 120 python dev-scripts/version-management/analyze-commits.py \
              --output json \
              --verbose > "$ANALYSIS_FILE" 2>"$ERROR_FILE"; then
              echo "❌ Error running analyze-commits.py (analyzing commits, exit code: $?):"
              cat "$ERROR_FILE"
              echo "--- Analysis file content (if any) ---"
              cat "$ANALYSIS_FILE" || echo "No analysis file created"
              exit 1
            fi
          fi

          # Verify the file was created and is not empty
          if [[ ! -f "$ANALYSIS_FILE" || ! -s "$ANALYSIS_FILE" ]]; then
            echo "❌ Error: Analysis file is empty or missing"
            exit 1
          fi

          # Validate JSON format
          if ! jq empty "$ANALYSIS_FILE" 2>/dev/null; then
            echo "❌ Error: Invalid JSON in analysis file"
            echo "File content:"
            head -20 "$ANALYSIS_FILE"
            exit 1
          fi

          # Extract key information
          CURRENT_VERSION=$(jq -r '.current_version' "$ANALYSIS_FILE")
          NEXT_VERSION=$(jq -r '.next_version' "$ANALYSIS_FILE")
          BUMP_TYPE=$(jq -r '.recommended_bump' "$ANALYSIS_FILE")
          TOTAL_COMMITS=$(jq -r '.total_commits' "$ANALYSIS_FILE")

          echo "current-version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "next-version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "bump-type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "has-changes=$([ $TOTAL_COMMITS -gt 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

          # Debug: Show analysis file content
          echo "📄 Analysis file content:"
          cat "$ANALYSIS_FILE"
          echo ""

          # Save analysis result using artifacts to avoid secret detection
          # GitHub Actions can detect large JSON content as potential secrets
          echo "💾 Saving analysis result as artifact..."

          # Create artifacts directory
          mkdir -p workflow-artifacts
          cp "$ANALYSIS_FILE" workflow-artifacts/analysis-result.json

          # Save just the key metadata as outputs (safe, no large JSON content)
          echo "analysis-available=true" >> $GITHUB_OUTPUT

          echo "📋 Analysis complete:"
          echo "  Current version: $CURRENT_VERSION"
          echo "  Next version: $NEXT_VERSION"
          echo "  Bump type: $BUMP_TYPE"
          echo "  Total commits: $TOTAL_COMMITS"

      - name: Upload analysis artifacts
        uses: actions/upload-artifact@v4
        with:
          name: commit-analysis-${{ github.run_id }}
          path: workflow-artifacts/
          retention-days: 1

  # Calculate final version with validation
  calculate-version:
    needs: analyze-commits
    if: needs.analyze-commits.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    outputs:
      final-version: ${{ steps.calculate.outputs.final-version }}
      version-tag: ${{ steps.calculate.outputs.version-tag }}
      is-prerelease: ${{ steps.calculate.outputs.is-prerelease }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-tags: true  # Ensure tags are fetched

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        timeout-minutes: ${{ fromJSON(env.SETUP_TIMEOUT) }}
        run: |
          python -m pip install --upgrade pip
          pip install -e dev-scripts/version-management/

      - name: Download analysis artifacts
        uses: actions/download-artifact@v4
        with:
          name: commit-analysis-${{ github.run_id }}
          path: workflow-artifacts/

      - name: Calculate version
        id: calculate
        env:
          RELEASE_TYPE: ${{ github.event.inputs.release-type || 'auto' }}
        run: |
          echo "🔢 Calculating final version..."
          echo "Release type: $RELEASE_TYPE"

          # Use analysis result from artifact
          if [[ -f "workflow-artifacts/analysis-result.json" ]]; then
            echo "Using analysis result from artifact"
            cp workflow-artifacts/analysis-result.json analysis.json
          else
            echo "❌ Error: Analysis result artifact not found"
            exit 1
          fi

          # Debug: Validate JSON
          if ! jq . analysis.json > /dev/null 2>&1; then
            echo "❌ Error: Invalid JSON in ANALYSIS_RESULT"
            echo "Content:"
            cat analysis.json
            exit 1
          fi

          # Determine release parameters based on release type and branch
          CURRENT_BRANCH="${{ github.ref_name }}"
          EVENT_NAME="${{ github.event_name }}"
          echo "Current branch: $CURRENT_BRANCH"
          echo "Event name: $EVENT_NAME"

          PRERELEASE_ID=""
          OVERRIDE_BUMP=""
          PROMOTE_FROM_PRERELEASE=false

          # Function to validate version format
          validate_version() {
            local version=$1
            if [[ ! $version =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
              echo "::error::Invalid version format: $version"
              return 1
            fi
            return 0
          }

          if [[ "$RELEASE_TYPE" == "prerelease" ]]; then
            # Explicit prerelease requested
            PRERELEASE_ID="beta"
            OVERRIDE_BUMP="patch"
            echo "🔀 Explicit pre-release requested - creating beta pre-release"
          elif [[ "$CURRENT_BRANCH" == feature/* ]]; then
            # Feature branch - always create pre-release
            PRERELEASE_ID="beta"
            OVERRIDE_BUMP="patch"
            echo "🔀 Feature branch detected - creating pre-release with beta suffix"
          elif [[ "$CURRENT_BRANCH" == develop* || "$CURRENT_BRANCH" == dev* ]]; then
            # Development branch - always create pre-release
            PRERELEASE_ID="alpha"
            OVERRIDE_BUMP="patch"
            echo "🔀 Development branch detected - creating pre-release with alpha suffix"
          elif [[ "$CURRENT_BRANCH" == "main" && "$EVENT_NAME" == "pull_request" ]]; then
            # PR merged to main - promote from pre-release to stable release
            PROMOTE_FROM_PRERELEASE=true
            echo "📦 PR merged to main - promoting from pre-release to stable release"

            # Get the latest tag to check for pre-release
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [[ "$LATEST_TAG" =~ v?[0-9]+\.[0-9]+\.[0-9]+-.+ ]]; then
              # This logic handles the promotion of a pre-release to a stable release.
              # When a pull request is merged into the main branch, this workflow
              # checks for the latest tag. If the latest tag is a pre-release version
              # (e.g., v1.2.3-alpha.1), it strips the pre-release suffix to determine
              # the new stable version (e.g., 1.2.3). This stable version is then
              # used for the new release, effectively "promoting" the pre-release.
              echo "🔄 Found pre-release version to promote: $LATEST_TAG"
              # Remove pre-release suffix (everything after the dash) to get stable version
              STABLE_VERSION=$(echo "$LATEST_TAG" | sed 's/v//' | sed 's/-.*$//')

              # Validate the extracted stable version
              if ! validate_version "$STABLE_VERSION"; then
                echo "::error::Failed to promote version: Invalid stable version format."
                exit 1
              fi

              jq --arg version "$STABLE_VERSION" '.next_version = $version' analysis.json > analysis-temp.json && mv analysis-temp.json analysis.json
              echo "🎯 Promoting to stable version: $STABLE_VERSION"
            else
              echo "ℹ️ No pre-release version found, using normal version calculation"
            fi
          elif [[ "$RELEASE_TYPE" != "auto" ]]; then
            # Manual override for main branch
            OVERRIDE_BUMP="$RELEASE_TYPE"
            echo "📦 Manual release type specified: $RELEASE_TYPE"
          fi

          # Apply overrides to analysis
          if [[ -n "$OVERRIDE_BUMP" ]]; then
            jq --arg bump "$OVERRIDE_BUMP" '.recommended_bump = $bump' analysis.json > analysis-temp.json && mv analysis-temp.json analysis.json
            echo "Overriding bump type to: $OVERRIDE_BUMP"
          fi

          # Calculate version
          CALC_ARGS="--analysis analysis.json --output json"

          if [[ -n "$PRERELEASE_ID" ]]; then
            CALC_ARGS="$CALC_ARGS --prerelease $PRERELEASE_ID"
            echo "📦 Using pre-release identifier: $PRERELEASE_ID"
          fi

          # Run calculation
          eval "python dev-scripts/version-management/calculate-version.py $CALC_ARGS" > version-calc.json

          # Extract results
          FINAL_VERSION=$(cat version-calc.json | jq -r '.next_version')
          VERSION_TAG=$(cat version-calc.json | jq -r '.suggested_tag')
          IS_PRERELEASE=$(cat version-calc.json | jq -r '.is_prerelease')

          echo "final-version=$FINAL_VERSION" >> $GITHUB_OUTPUT
          echo "version-tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "is-prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT

          echo "✅ Version calculation complete:"
          echo "  Final version: $FINAL_VERSION"
          echo "  Git tag: $VERSION_TAG"
          echo "  Is pre-release: $IS_PRERELEASE"

  # Update package version files to match calculated version
  update-version:
    needs: [analyze-commits, calculate-version]
    if: needs.analyze-commits.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ github.token }}
          fetch-tags: true  # Ensure tags are fetched

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        timeout-minutes: ${{ fromJSON(env.SETUP_TIMEOUT) }}
        run: |
          python -m pip install --upgrade pip
          pip install -e dev-scripts/version-management/

      - name: Update package.json version
        run: |
          echo "📝 Updating package.json to version ${{ needs.calculate-version.outputs.final-version }}..."

          # Update the version in package.json
          NEW_VERSION="${{ needs.calculate-version.outputs.final-version }}"

          # Use npm version to update (without creating a git tag)
          npm version "$NEW_VERSION" --no-git-tag-version

          # Verify the change
          echo "Updated version in package.json:"
          grep '"version"' package.json

          # Check if there are any changes to commit
          if git diff --quiet package.json; then
            echo "No changes needed - version already up to date"
          else
            echo "✅ Version updated successfully"
          fi

      - name: Commit version update
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if there are changes to commit
          if git diff --quiet package.json; then
            echo "No version changes to commit"
          else
            # Add and commit the version update
            git add package.json
            git commit -m "$(cat <<'EOF'
          chore: update version to ${{ needs.calculate-version.outputs.final-version }} for release

          Automatically updated by release-notes-generator workflow.

          🤖 Generated with [Claude Code](https://claude.ai/code)

          Co-Authored-By: Claude <noreply@anthropic.com>
          EOF
          )"

            # Push the changes
            git push
            echo "✅ Version update committed and pushed"
          fi

      - name: Validate version
        run: |
          echo "🔍 Validating version progression..."
          python dev-scripts/version-management/validate-version.py \
            --version ${{ needs.calculate-version.outputs.final-version }} \
            --output text

  # Generate release notes
  generate-notes:
    needs: [analyze-commits, calculate-version, update-version]
    if: needs.analyze-commits.outputs.has-changes == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      release-notes-md: ${{ steps.generate.outputs.release-notes-md }}
      release-notes-json: ${{ steps.generate.outputs.release-notes-json }}
      release-notes-generated: ${{ steps.generate.outputs.release-notes-generated }}
      changelog-entry: ${{ steps.generate.outputs.changelog-entry }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true  # Ensure tags are fetched

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        timeout-minutes: ${{ fromJSON(env.SETUP_TIMEOUT) }}
        run: |
          python -m pip install --upgrade pip
          pip install -e dev-scripts/version-management/ Jinja2

      - name: Download analysis artifacts
        uses: actions/download-artifact@v4
        with:
          name: commit-analysis-${{ github.run_id }}
          path: workflow-artifacts/

      - name: Generate release notes
        id: generate
        run: |
          echo "📝 Generating release notes..."

          # Create release notes generation script
          cat > generate_release_notes.py << 'EOF'
          #!/usr/bin/env python3
          import json
          import yaml
          from datetime import datetime
          from pathlib import Path

          # Load analysis data
          with open('analysis.json', 'r') as f:
              analysis = json.load(f)

          # Load configuration
          config_path = Path('.github/semver-config.yml')
          if config_path.exists():
              with open(config_path, 'r') as f:
                  config = yaml.safe_load(f)
          else:
              config = {}

          # Get release notes config
          notes_config = config.get('release_notes', {})
          categories = notes_config.get('categories', [])

          # Organize commits by category
          categorized_commits = {}
          for category in categories:
              categorized_commits[category['name']] = []

          # Default category for uncategorized commits
          categorized_commits['🔧 Other Changes'] = []

          # Categorize commits
          for commit in analysis.get('commits', []):
              categorized = False
              commit_type = commit.get('type', '')

              for category in categories:
                  if commit_type in category.get('commit_types', []):
                      categorized_commits[category['name']].append(commit)
                      categorized = True
                      break

              if not categorized:
                  categorized_commits['🔧 Other Changes'].append(commit)

          # Generate markdown
          version = "${{ needs.calculate-version.outputs.final-version }}"
          date = datetime.now().strftime('%Y-%m-%d')

          md_lines = [
              f"# Release {version}",
              f"",
              f"**Release Date:** {date}",
              f"**Version Type:** {analysis.get('recommended_bump', 'patch').title()}",
              f"",
          ]

          # Add summary
          total_commits = analysis.get('total_commits', 0)
          feature_count = analysis.get('feature_count', 0)
          fix_count = analysis.get('fix_count', 0)
          breaking_count = len(analysis.get('breaking_changes', []))

          md_lines.extend([
              "## 📊 Summary",
              "",
              f"- **Total Changes:** {total_commits} commits",
              f"- **New Features:** {feature_count}",
              f"- **Bug Fixes:** {fix_count}",
              f"- **Breaking Changes:** {breaking_count}",
              "",
          ])

          # Add breaking changes first if any
          if breaking_count > 0:
              md_lines.extend([
                  "## 💥 Breaking Changes",
                  "",
              ])
              for change in analysis.get('breaking_changes', []):
                  md_lines.append(f"- {change}")
              md_lines.append("")

          # Add categorized changes
          for category_name, commits in categorized_commits.items():
              if commits:
                  md_lines.extend([
                      f"## {category_name}",
                      "",
                  ])
                  for commit in commits:
                      desc = commit.get('description', commit.get('message', '').split('\n')[0])
                      hash_short = commit.get('hash', '')[:7]
                      md_lines.append(f"- {desc} ({hash_short})")
                  md_lines.append("")

          # Write markdown file
          with open('release-notes.md', 'w') as f:
              f.write('\n'.join(md_lines))

          # Generate JSON format
          json_data = {
              "version": version,
              "date": date,
              "bump_type": analysis.get('recommended_bump', 'patch'),
              "summary": {
                  "total_commits": total_commits,
                  "feature_count": feature_count,
                  "fix_count": fix_count,
                  "breaking_count": breaking_count
              },
              "breaking_changes": analysis.get('breaking_changes', []),
              "categories": {name: commits for name, commits in categorized_commits.items() if commits},
              "commits": analysis.get('commits', [])
          }

          with open('release-notes.json', 'w') as f:
              json.dump(json_data, f, indent=2)

          # Generate changelog entry
          changelog_lines = [
              f"## [{version}] - {date}",
              "",
          ]

          if breaking_count > 0:
              changelog_lines.extend([
                  "### Breaking Changes",
                  "",
              ])
              for change in analysis.get('breaking_changes', []):
                  changelog_lines.append(f"- {change}")
              changelog_lines.append("")

          for category_name, commits in categorized_commits.items():
              if commits and category_name != '🔧 Other Changes':
                  # Convert emoji categories to standard changelog sections
                  section_name = category_name.split(' ', 1)[1] if ' ' in category_name else category_name
                  changelog_lines.extend([
                      f"### {section_name}",
                      "",
                  ])
                  for commit in commits:
                      desc = commit.get('description', commit.get('message', '').split('\n')[0])
                      changelog_lines.append(f"- {desc}")
                  changelog_lines.append("")

          with open('changelog-entry.md', 'w') as f:
              f.write('\n'.join(changelog_lines))

          print("✅ Release notes generated successfully")
          EOF

          # Use analysis result from artifact
          if [[ -f "workflow-artifacts/analysis-result.json" ]]; then
            echo "Using analysis result from artifact"
            cp workflow-artifacts/analysis-result.json analysis.json
          else
            echo "❌ Error: Analysis result artifact not found in generate-notes job"
            exit 1
          fi

          # Debug: Validate JSON
          if ! jq . analysis.json > /dev/null 2>&1; then
            echo "❌ Error: Invalid JSON in ANALYSIS_RESULT"
            echo "Content:"
            cat analysis.json
            exit 1
          fi

          # Generate release notes
          python generate_release_notes.py

          # Set outputs using file-based approach for reliability
          # This avoids delimiter issues entirely by saving to files

          # For markdown - use simple EOF since it's unlikely to appear
          {
            echo "release-notes-md<<EOF"
            cat release-notes.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

          # For JSON - use single-line output to avoid delimiter issues
          # This reads the entire JSON file into a single line
          JSON_CONTENT=$(jq -c . release-notes.json)
          echo "release-notes-json=${JSON_CONTENT}" >> $GITHUB_OUTPUT

          # Also save file reference and success indicator
          echo "release-notes-json-file=release-notes.json" >> $GITHUB_OUTPUT
          echo "release-notes-generated=true" >> $GITHUB_OUTPUT

          # For changelog - use simple EOF
          {
            echo "changelog-entry<<EOF"
            cat changelog-entry.md
            echo "EOF"
          } >> $GITHUB_OUTPUT

      - name: Upload release notes artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-notes-${{ needs.calculate-version.outputs.final-version }}
          path: |
            release-notes.md
            release-notes.json
            changelog-entry.md

  # Optional AI enhancement - uses Claude to improve release note quality
  # Only runs when explicitly enabled and emergency controls allow it
  ai-enhance-notes:
    needs: [analyze-commits, calculate-version, update-version, generate-notes]
    # Conditional execution with multiple safety checks:
    # - has-changes: Only enhance if there are actual changes to document
    # - enable-ai-enhancement: Manual workflow input flag (cost control)
    # - EMERGENCY_STOP: Respects emergency halt (safety override)
    # - MAINTENANCE_MODE: Avoids AI operations during maintenance
    if: |
      needs.analyze-commits.outputs.has-changes == 'true' &&
      github.event.inputs.enable-ai-enhancement == 'true' &&
      vars.EMERGENCY_STOP != 'true' &&
      vars.MAINTENANCE_MODE != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 10  # AI execution timeout (secrets cannot be used in timeout-minutes context)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install OpenRouter dependencies
        run: |
          pip install openai==1.54.3 httpx==0.27.0

      - name: Enhance release notes with AI
        env:
          # OPENROUTER_API_KEY: Repository secret containing OpenRouter API credentials
          # Required for AI enhancement functionality - costs are controlled via timeouts and input gating
          OPENROUTER_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          AI_MODEL: ${{ vars.AI_MODEL || 'anthropic/claude-3.5-sonnet' }}
        run: |
          echo "🤖 Enhancing release notes with AI..."

          # Prepare release notes for enhancement
          echo '${{ needs.generate-notes.outputs.release-notes-md }}' > raw-notes.md

          # Use AI via OpenRouter to enhance the release notes
          # Enhancement focuses on clarity and user understanding while preserving structure
          PROMPT="Please enhance these release notes by improving descriptions "
          PROMPT+="and adding helpful context while maintaining the same structure "
          PROMPT+="and format. Focus on making the changes more understandable for users:"

          # Create prompt file with raw notes
          echo "$PROMPT" > enhancement-prompt.md
          echo "" >> enhancement-prompt.md
          cat raw-notes.md >> enhancement-prompt.md

          echo "🤖 Using $AI_MODEL via OpenRouter to enhance release notes..."
          python ./scripts/openrouter-ai-helper.py \
            --prompt-file enhancement-prompt.md \
            --output-file enhanced-notes.md \
            --model "$AI_MODEL" \
            --title "Release Notes Enhancement"

          echo "✅ Release notes enhanced successfully"

          # Upload enhanced notes as artifact
          mkdir -p enhanced-release-notes
          cp enhanced-notes.md enhanced-release-notes/

      - name: Upload enhanced notes
        uses: actions/upload-artifact@v4
        with:
          name: enhanced-release-notes-${{ needs.calculate-version.outputs.final-version }}
          path: enhanced-release-notes/

  # Create GitHub release
  create-release:
    needs: [calculate-version, update-version, generate-notes, ai-enhance-notes]
    if: |
      always() &&
      needs.calculate-version.result == 'success' &&
      needs.update-version.result == 'success' &&
      needs.generate-notes.result == 'success' &&
      (needs.ai-enhance-notes.result == 'success' || needs.ai-enhance-notes.result == 'skipped')
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create git tag
        run: |
          set -e
          VERSION_TAG="${{ needs.calculate-version.outputs.version-tag }}"
          # Remove any stray quotes
          VERSION_TAG=$(echo "$VERSION_TAG" | sed 's/"//g')
          echo "🏷️ Creating git tag: $VERSION_TAG"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if tag already exists
          if git rev-parse "$VERSION_TAG" >/dev/null 2>&1; then
            echo "Tag $VERSION_TAG already exists"
            exit 0
          fi

          git tag -a "$VERSION_TAG" -m "Release $VERSION_TAG"
          git push origin "$VERSION_TAG"

      - name: Create GitHub release
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -e
          VERSION_TAG="${{ needs.calculate-version.outputs.version-tag }}"
          # Remove any stray quotes
          VERSION_TAG=$(echo "$VERSION_TAG" | sed 's/"//g')
          IS_PRERELEASE="${{ needs.calculate-version.outputs.is-prerelease }}"

          # Fetch tags to ensure we have the latest
          git fetch --tags

          # Prepare release notes
          echo '${{ needs.generate-notes.outputs.release-notes-md }}' > release-notes.md

          # Create release - use array to properly handle arguments
          RELEASE_ARGS=(--title "Release $VERSION_TAG" --notes-file release-notes.md)

          if [[ "$IS_PRERELEASE" == "true" ]]; then
            RELEASE_ARGS+=(--prerelease)
          fi

          echo "🚀 Creating GitHub release: $VERSION_TAG"
          gh release create "$VERSION_TAG" "${RELEASE_ARGS[@]}"

  # Publish to npm
  publish-npm:
    needs: [calculate-version, update-version]
    if: |
      needs.calculate-version.result == 'success' &&
      needs.update-version.result == 'success' &&
      (
        (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')) ||
        (github.event_name == 'workflow_dispatch' && github.event.inputs.publish-npm == 'true') ||
        (
          github.event_name == 'pull_request' &&
          github.event.pull_request.merged == true &&
          github.event.pull_request.base.ref == 'main' &&
          contains(github.event.pull_request.labels.*.name, 'release')
        )
      )
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      id-token: write  # For npm provenance
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest changes
        run: |
          echo "📥 Fetching latest changes including version update..."
          git fetch origin ${{ github.ref_name }}
          git checkout origin/${{ github.ref_name }}
          echo "✅ Now on latest commit with version updates"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'

      - name: Verify version
        run: |
          echo "📦 Preparing to publish version ${{ needs.calculate-version.outputs.final-version }}"

          # Verify package.json version matches
          PACKAGE_VERSION=$(node -p "require('./package.json').version")
          EXPECTED_VERSION="${{ needs.calculate-version.outputs.final-version }}"

          if [[ "$PACKAGE_VERSION" != "$EXPECTED_VERSION" ]]; then
            echo "❌ Version mismatch!"
            echo "  Package.json: $PACKAGE_VERSION"
            echo "  Expected: $EXPECTED_VERSION"
            exit 1
          fi

          echo "✅ Version verified: $PACKAGE_VERSION"

      - name: Check npm access
        run: |
          # Check if package exists and we have access
          PACKAGE_NAME=$(node -p "require('./package.json').name")

          if npm view "$PACKAGE_NAME" version 2>/dev/null; then
            echo "📦 Package exists on npm: $PACKAGE_NAME"
            LATEST_VERSION=$(npm view "$PACKAGE_NAME" version)
            echo "  Latest published version: $LATEST_VERSION"
          else
            echo "📦 This will be the first publish of: $PACKAGE_NAME"
          fi

      - name: Publish to npm
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          echo "🚀 Publishing to npm..."

          # Validate npm token is available
          if [[ -z "$NODE_AUTH_TOKEN" ]]; then
            echo "❌ Error: NPM_TOKEN secret is not set"
            echo "Please add NPM_TOKEN to your repository secrets"
            exit 1
          fi

          # Publish with error handling and retry logic
          RETRY_COUNT=0
          MAX_RETRIES=3

          while [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; do
            if npm publish --access public; then
              echo "✅ Successfully published to npm!"
              break
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [[ $RETRY_COUNT -lt $MAX_RETRIES ]]; then
                echo "⚠️ Publish failed, retrying in 10 seconds (attempt $RETRY_COUNT/$MAX_RETRIES)..."
                sleep 10
              else
                echo "❌ Failed to publish after $MAX_RETRIES attempts"
                echo "This may be due to:"
                echo "  - Invalid npm token"
                echo "  - Package name already exists with different owner"
                echo "  - Version already published"
                echo "  - Network connectivity issues"
                exit 1
              fi
            fi
          done

      - name: Verify publication
        run: |
          # Wait a moment for npm to update
          sleep 5

          PACKAGE_NAME=$(node -p "require('./package.json').name")
          PUBLISHED_VERSION=$(npm view "$PACKAGE_NAME" version)
          EXPECTED_VERSION="${{ needs.calculate-version.outputs.final-version }}"

          echo "📦 Published version: $PUBLISHED_VERSION"

          if [[ "$PUBLISHED_VERSION" == "$EXPECTED_VERSION" ]]; then
            echo "✅ Version $EXPECTED_VERSION successfully published to npm!"
          else
            echo "⚠️ Published version may not be updated yet"
            echo "  Expected: $EXPECTED_VERSION"
            echo "  Current on npm: $PUBLISHED_VERSION"
          fi

  # Update changelog
  update-changelog:
    needs: [calculate-version, update-version, generate-notes, create-release]
    if: |
      always() &&
      needs.create-release.result == 'success' &&
      github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ github.token }}

      - name: Update CHANGELOG.md
        run: |
          echo "📝 Updating CHANGELOG.md"

          # Create CHANGELOG.md if it doesn't exist
          if [[ ! -f CHANGELOG.md ]]; then
            cat > CHANGELOG.md << 'EOF'
          # Changelog

          All notable changes to this project will be documented in this file.

          The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
          and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

          EOF
          fi

          # Prepare new changelog entry
          echo '${{ needs.generate-notes.outputs.changelog-entry }}' > new-entry.md

          # Insert new entry after the header
          {
            head -n 6 CHANGELOG.md
            echo ""
            cat new-entry.md
            echo ""
            tail -n +7 CHANGELOG.md
          } > CHANGELOG.new.md

          mv CHANGELOG.new.md CHANGELOG.md

          # Commit changes
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if git diff --quiet CHANGELOG.md; then
            echo "No changes to CHANGELOG.md"
          else
            git add CHANGELOG.md
            git commit -m "Update CHANGELOG.md for ${{ needs.calculate-version.outputs.version-tag }}"
            git push
          fi

  # Final status report
  report-status:
    needs: [emergency-check, analyze-commits, calculate-version, update-version, generate-notes, create-release, publish-npm]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    steps:
      - name: Report final status
        run: |
          echo "🎯 Release Notes Generation Summary"
          echo "=================================="

          if [[ "${{ needs.emergency-check.outputs.can-proceed }}" != "true" ]]; then
            echo "❌ Blocked by emergency controls: ${{ needs.emergency-check.outputs.emergency-reason }}"
            exit 0
          fi

          if [[ "${{ needs.analyze-commits.outputs.has-changes }}" != "true" ]]; then
            echo "ℹ️ No commits found since last release - no release notes generated"
            exit 0
          fi

          echo "📊 Analysis Results:"
          echo "  - Current version: ${{ needs.analyze-commits.outputs.current-version }}"
          echo "  - Next version: ${{ needs.calculate-version.outputs.final-version }}"
          echo "  - Bump type: ${{ needs.analyze-commits.outputs.bump-type }}"
          echo "  - Pre-release: ${{ needs.calculate-version.outputs.is-prerelease }}"

          echo ""
          echo "🎯 Workflow Results:"
          echo "  - Emergency check: ${{ needs.emergency-check.result }}"
          echo "  - Commit analysis: ${{ needs.analyze-commits.result }}"
          echo "  - Version calculation: ${{ needs.calculate-version.result }}"
          echo "  - Version update: ${{ needs.update-version.result }}"
          echo "  - Notes generation: ${{ needs.generate-notes.result }}"
          echo "  - Release creation: ${{ needs.create-release.result }}"
          echo "  - NPM publishing: ${{ needs.publish-npm.result }}"

          echo ""
          echo "🎯 Results Summary:"
          if [[ "${{ needs.publish-npm.result }}" == "success" ]]; then
            echo "✅ NPM package published successfully!"
            echo "📦 Version ${{ needs.calculate-version.outputs.final-version }} is now available on npm"
          elif [[ "${{ needs.publish-npm.result }}" == "skipped" ]]; then
            echo "📦 NPM publishing skipped (not triggered)"
          else
            echo "❌ NPM publishing failed"
          fi

          if [[ "${{ needs.create-release.result }}" == "success" ]]; then
            echo "✅ GitHub release ${{ needs.calculate-version.outputs.version-tag }} created successfully!"
            echo "🔗 View release: ${{ github.server_url }}/${{ github.repository }}/releases/tag/" \
              "${{ needs.calculate-version.outputs.version-tag }}"
          elif [[ "${{ needs.create-release.result }}" == "skipped" ]]; then
            echo "📋 GitHub release skipped"
          else
            echo "❌ GitHub release creation failed"
          fi

      - name: Collect workflow metrics
        if: always()
        run: |
          echo "📊 Collecting workflow performance metrics..."

          # Calculate workflow duration
          WORKFLOW_START=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          WORKFLOW_END=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Job statuses
          EMERGENCY_CHECK_STATUS="${{ needs.emergency-check.result }}"
          ANALYZE_COMMITS_STATUS="${{ needs.analyze-commits.result }}"
          CALCULATE_VERSION_STATUS="${{ needs.calculate-version.result }}"
          UPDATE_VERSION_STATUS="${{ needs.update-version.result }}"
          GENERATE_NOTES_STATUS="${{ needs.generate-notes.result }}"
          AI_ENHANCE_STATUS="${{ needs.ai-enhance-notes.result }}"
          CREATE_RELEASE_STATUS="${{ needs.create-release.result }}"

          # Generate metrics report
          cat > workflow-metrics.json << EOF
          {
            "workflow_run_id": "${{ github.run_id }}",
            "workflow_run_number": "${{ github.run_number }}",
            "repository": "${{ github.repository }}",
            "ref": "${{ github.ref }}",
            "sha": "${{ github.sha }}",
            "actor": "${{ github.actor }}",
            "event_name": "${{ github.event_name }}",
            "started_at": "${WORKFLOW_START}",
            "completed_at": "${WORKFLOW_END}",
            "job_statuses": {
              "emergency_check": "${EMERGENCY_CHECK_STATUS}",
              "analyze_commits": "${ANALYZE_COMMITS_STATUS}",
              "calculate_version": "${CALCULATE_VERSION_STATUS}",
              "update_version": "${UPDATE_VERSION_STATUS}",
              "generate_notes": "${GENERATE_NOTES_STATUS}",
              "ai_enhance": "${AI_ENHANCE_STATUS}",
              "create_release": "${CREATE_RELEASE_STATUS}"
            },
            "version_info": {
              "current_version": "${{ needs.analyze-commits.outputs.current-version }}",
              "next_version": "${{ needs.calculate-version.outputs.final-version }}",
              "bump_type": "${{ needs.analyze-commits.outputs.bump-type }}",
              "is_prerelease": "${{ needs.calculate-version.outputs.is-prerelease }}",
              "has_changes": "${{ needs.analyze-commits.outputs.has-changes }}"
            },
            "success": $([ "${CREATE_RELEASE_STATUS}" == "success" ] && echo "true" || echo "false")
          }
          EOF

          echo "📈 Workflow metrics collected"
          cat workflow-metrics.json

          # Set output for downstream tools
          echo "workflow_status=$([ \"${CREATE_RELEASE_STATUS}\" == \"success\" ] && " \
            "echo \"success\" || echo \"failure\")" >> $GITHUB_ENV

      - name: Upload metrics artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: workflow-metrics-${{ github.run_id }}
          path: workflow-metrics.json
          retention-days: 30
